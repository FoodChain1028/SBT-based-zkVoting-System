"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LabeledWitness = exports.CircuitTestUtils = exports.TASK_CIRCOM_TEMPLATE = exports.TASK_CIRCOM = exports.PLUGIN_NAME = void 0;
const path = __importStar(require("path"));
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs/promises"));
const nodefs = __importStar(require("fs"));
const util_1 = require("util");
const assert_1 = __importDefault(require("assert"));
const unionfs_1 = require("@phated/unionfs");
const memfs_1 = require("memfs");
const fs_1 = require("fs");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const camelcase_1 = __importDefault(require("camelcase"));
const shimmer_1 = __importDefault(require("shimmer"));
const undici_1 = require("undici");
const bl_1 = __importDefault(require("bl"));
const logger_1 = __importDefault(require("./logger"));
const snarkjs_1 = __importDefault(require("./snarkjs"));
// @ts-ignore because they don't ship types
const circom1Compiler = __importStar(require("circom"));
// @ts-ignore because they don't ship types
const circom2_1 = require("circom2");
// @ts-ignore because they don't ship types
const circom_runtime_1 = require("circom_runtime");
// @ts-ignore because they don't ship types
const r1csfile_1 = require("r1csfile");
// @ts-ignore because they don't ship types
const ffjavascript_1 = require("ffjavascript");
config_1.extendEnvironment((hre) => {
    hre.circom = circom1Compiler;
    hre.snarkjs = snarkjs_1.default;
    hre.circuitTest = plugins_1.lazyObject(() => {
        let hasDebug = false;
        const testDebugPath = path.join(hre.config.paths.artifacts, "circom/test");
        return {
            async setup(whichCircuit, { debug } = { debug: false }) {
                if (debug) {
                    hasDebug = true;
                }
                for (const circuit of hre.config.circom.circuits) {
                    if (whichCircuit !== circuit.name) {
                        continue;
                    }
                    const compiler = circuit.version === 1 ? circom1 : circom2;
                    let compilerOutput;
                    try {
                        compilerOutput = await compiler({
                            circuit,
                            debug: debug ? { path: testDebugPath } : undefined,
                        });
                    }
                    catch (err) {
                        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to compile circuit named: ${circuit.name}`, err);
                    }
                    return new CircuitTestUtils(compilerOutput);
                }
                throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to locate circuit named: ${whichCircuit}`);
            },
            async teardown() {
                if (hasDebug) {
                    await fs.rm(testDebugPath, { recursive: true });
                }
            },
        };
    });
});
exports.PLUGIN_NAME = "hardhat-circom";
exports.TASK_CIRCOM = "circom";
exports.TASK_CIRCOM_TEMPLATE = "circom:template";
config_1.extendConfig((config, userConfig) => {
    const { root } = config.paths;
    const { inputBasePath, outputBasePath, ptau, circuits = [] } = userConfig.circom ?? {};
    if (circuits.length === 0) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, "Missing required circuits list, please provide via hardhat.config.js (circom.circuits) a list of circuit names to load from the inputBasePath");
    }
    if (!ptau) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, "Missing required ptau location, please provide via hardhat.config.js (circom.ptau) the location of your ptau file");
    }
    const defaultInputBasePath = path.join(root, "circuits");
    const defaultOutputBasePath = path.join(root, "circuits");
    const normalizedInputBasePath = normalize(root, inputBasePath) ?? defaultInputBasePath;
    const normalizedOutputBasePath = normalize(root, outputBasePath) ?? defaultOutputBasePath;
    const ptauIsUrl = ptau.startsWith("http://") || ptau.startsWith("https://");
    let normalizedPtauPath;
    if (ptauIsUrl) {
        const ptauFile = ptau.replace(/^(http:|https:)\/\//, "").replace(/\//g, "_");
        // TODO: This is used here and as the debug path. That should probably be normalized into the config
        const artifactPath = path.join(config.paths.artifacts, "circom");
        normalizedPtauPath = path.join(artifactPath, ptauFile);
    }
    else {
        normalizedPtauPath = path.resolve(normalizedInputBasePath, ptau);
    }
    config.circom = {
        inputBasePath: normalizedInputBasePath,
        outputBasePath: normalizedOutputBasePath,
        ptau: normalizedPtauPath,
        ptauDownload: ptauIsUrl ? ptau : undefined,
        circuits: [],
    };
    for (const { name, version, protocol, beacon, circuit, input, wasm, r1cs, zkey, vkey } of circuits) {
        if (!name) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, "Missing required name field in circuits list, please provide via hardhat.config.js (circom.circuits.name)");
        }
        const circuitPath = path.resolve(normalizedInputBasePath, circuit ?? `${name}.circom`);
        const inputPath = path.resolve(normalizedInputBasePath, input ?? `${name}.json`);
        const wasmPath = path.resolve(normalizedOutputBasePath, wasm ?? `${name}.wasm`);
        const r1csPath = path.resolve(normalizedOutputBasePath, r1cs ?? `${name}.r1cs`);
        const zkeyPath = path.resolve(normalizedOutputBasePath, zkey ?? `${name}.zkey`);
        const vkeyPath = path.resolve(normalizedOutputBasePath, vkey ?? `${name}.vkey.json`);
        config.circom.circuits.push({
            name: name,
            version: version !== 1 ? 2 : 1,
            protocol: protocol !== "plonk" ? "groth16" : "plonk",
            beacon: beacon != null ? beacon : "0000000000000000000000000000000000000000000000000000000000000000",
            circuit: circuitPath,
            input: inputPath,
            wasm: wasmPath,
            r1cs: r1csPath,
            zkey: zkeyPath,
            vkey: vkeyPath,
        });
    }
});
async function getInputJson(input) {
    const inputString = await fs.readFile(input, "utf8");
    try {
        return JSON.parse(inputString);
    }
    catch (err) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Failed to parse JSON in file: ${input}`, err);
    }
}
async function circom1({ circuit, debug }) {
    const r1csFastFile = { type: "mem" };
    const wasmFastFile = { type: "mem" };
    const watFastFile = { type: "mem" };
    const symWriteStream = new bl_1.default();
    await circom1Compiler.compiler(circuit.circuit, {
        watFileName: watFastFile,
        wasmFileName: wasmFastFile,
        r1csFileName: r1csFastFile,
        symWriteStream,
    });
    const symFastFile = {
        type: "mem",
        data: symWriteStream.slice(),
    };
    if (!r1csFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate r1cs for circuit named: ${circuit.name}`);
    }
    if (!wasmFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate wasm for circuit named: ${circuit.name}`);
    }
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.r1cs`), r1csFastFile.data);
        await fs.writeFile(path.join(debug.path, `${circuit.name}.wasm`), wasmFastFile.data);
        // The .wat file is only used for debug
        if (watFastFile.data) {
            await fs.writeFile(path.join(debug.path, `${circuit.name}.wat`), watFastFile.data);
        }
        // The .sym file is only used for debug
        if (symFastFile.data) {
            await fs.writeFile(path.join(debug.path, `${circuit.name}.sym`), symFastFile.data);
        }
    }
    return {
        // the `.data` property is checked above
        r1cs: r1csFastFile,
        wasm: wasmFastFile,
        sym: symFastFile,
    };
}
async function circom2({ circuit, debug }) {
    // Prepare a virtual filesystem because circom2 only operates on files
    const vol = memfs_1.Volume.fromJSON({
        "/dev/stdin": "",
        "/dev/stdout": "",
        "/dev/stderr": "",
    });
    const memfs = memfs_1.createFsFromVolume(vol);
    // Using this order to prefer writing virtual files from the circom2 wasm
    unionfs_1.ufs
        .use(nodefs)
        // I hate typescript
        .use(memfs);
    // Get the circuit's filename without extension
    // This is what circom2 names all files it outputs (with different extensions)
    const { name: circuitName, dir } = path.parse(circuit.circuit);
    const wasmDir = path.join(dir, `${circuitName}_js`);
    // We build virtual paths here because circom2 outputs these into dumb places
    const r1csVirtualPath = path.join(dir, `${circuitName}.r1cs`);
    const symVirtualPath = path.join(dir, `${circuitName}.sym`);
    const wasmVirtualPath = path.join(wasmDir, `${circuitName}.wasm`);
    const watVirtualPath = path.join(wasmDir, `${circuitName}.wat`);
    // Make the r1cs directory so it doesn't defer to nodefs for writing
    // but don't make the wasm directory because otherwise circom2 won't proceed
    await unionfs_1.ufs.promises.mkdir(dir, { recursive: true });
    let stdout = "";
    let stderr = "";
    // We wrap the writeSync function because circom2 doesn't allow us to
    // configure the logging and it doesn't exit with proper exit codes
    shimmer_1.default.wrap(unionfs_1.ufs, "writeSync", function (original) {
        return function (fd, data, offsetOrPosition, lengthOrEncoding, position) {
            // If writing to stdout, we hijack to hide unless debug
            if (fd === 1) {
                if (typeof data === "string") {
                    stdout += data;
                    // This is a little fragile, but we assume the wasmer-js
                    // terminal character is a newline by itself
                    if (stdout.endsWith("\n")) {
                        const msg = stdout.trim();
                        stdout = "";
                        logger_1.default.info(msg);
                    }
                    return data.length;
                }
                else {
                    stdout += new TextDecoder().decode(data);
                    // This is a little fragile, but we assume the wasmer-js
                    // terminal character is a newline by itself
                    if (stdout.endsWith("\n")) {
                        const msg = stdout.trim();
                        stdout = "";
                        logger_1.default.info(msg);
                    }
                    return data.byteLength;
                }
            }
            // If writing to stderr, we hijack and throw an error
            if (fd == 2) {
                if (typeof data === "string") {
                    stderr += data;
                    // This is a little fragile, but we assume that circom2
                    // ends the failed compile with "previous errors were found"
                    if (stderr.includes("previous errors were found")) {
                        const msg = stderr.trim();
                        stderr = "";
                        logger_1.default.error(msg);
                        throw new Error(msg);
                    }
                    return data.length;
                }
                else {
                    stderr += new TextDecoder().decode(data);
                    // This is a little fragile, but we assume that circom2
                    // ends the failed compile with "previous errors were found"
                    if (stderr.includes("previous errors were found")) {
                        const msg = stderr.trim();
                        stderr = "";
                        logger_1.default.error(msg);
                        throw new Error(msg);
                    }
                    return data.byteLength;
                }
            }
            if (typeof data === "string") {
                if (typeof lengthOrEncoding !== "number") {
                    return original(fd, data, offsetOrPosition, lengthOrEncoding);
                }
                else {
                    throw Error("Invalid arguments");
                }
            }
            else {
                if (typeof lengthOrEncoding !== "string") {
                    return original(fd, data, offsetOrPosition, lengthOrEncoding, position);
                }
                else {
                    throw Error("Invalid arguments");
                }
            }
        };
    });
    const circom = new circom2_1.CircomRunner({
        args: [circuit.circuit, "--r1cs", "--wat", "--wasm", "--sym", "-o", dir],
        env: {},
        // Preopen from the root because we use absolute paths
        preopens: {
            "/": "/",
        },
        bindings: {
            ...circom2_1.bindings,
            fs: unionfs_1.ufs,
        },
    });
    const circomWasm = await fs.readFile(require.resolve("circom2/circom.wasm"));
    await circom.execute(circomWasm);
    const r1csFastFile = {
        type: "mem",
        data: await unionfs_1.ufs.promises.readFile(r1csVirtualPath),
    };
    const symFastFile = {
        type: "mem",
        data: await unionfs_1.ufs.promises.readFile(symVirtualPath),
    };
    const wasmFastFile = {
        type: "mem",
        data: await unionfs_1.ufs.promises.readFile(wasmVirtualPath),
    };
    const watFastFile = {
        type: "mem",
        data: await unionfs_1.ufs.promises.readFile(watVirtualPath),
    };
    if (!r1csFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate r1cs for circuit named: ${circuit.name}`);
    }
    if (!wasmFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate wasm for circuit named: ${circuit.name}`);
    }
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.r1cs`), r1csFastFile.data);
        await fs.writeFile(path.join(debug.path, `${circuit.name}.wasm`), wasmFastFile.data);
        // The .wat file is only used for debug
        if (watFastFile.data) {
            await fs.writeFile(path.join(debug.path, `${circuit.name}.wat`), watFastFile.data);
        }
        // The .sym file is only used for debug
        if (symFastFile.data) {
            await fs.writeFile(path.join(debug.path, `${circuit.name}.sym`), symFastFile.data);
        }
    }
    return {
        // the `.data` property is checked above
        r1cs: r1csFastFile,
        wasm: wasmFastFile,
        sym: symFastFile,
    };
}
async function groth16({ circuit, deterministic, debug, wasm: wasmFastFile, r1cs: r1csFastFile, ptau, }) {
    const input = await getInputJson(circuit.input);
    const newKeyFastFile = { type: "mem" };
    const _csHash = await snarkjs_1.default.zKey.newZKey(r1csFastFile, ptau, newKeyFastFile);
    if (!newKeyFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate new zkey for circuit named: ${circuit.name}`);
    }
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}-contribution.zkey`), newKeyFastFile.data);
    }
    const beaconZkeyFastFile = { type: "mem" };
    const _contributionHash = await snarkjs_1.default.zKey.beacon(newKeyFastFile, beaconZkeyFastFile, undefined, deterministic ? circuit.beacon : crypto.randomBytes(32).toString("hex"), 10);
    if (!beaconZkeyFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate beacon zkey for circuit named: ${circuit.name}`);
    }
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.zkey`), beaconZkeyFastFile.data);
    }
    const verificationKey = await snarkjs_1.default.zKey.exportVerificationKey(beaconZkeyFastFile);
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.vkey.json`), JSON.stringify(verificationKey));
    }
    const wtnsFastFile = { type: "mem" };
    await snarkjs_1.default.wtns.calculate(input, wasmFastFile, wtnsFastFile);
    if (!wtnsFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate witness for circuit named: ${circuit.name}`);
    }
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.wtns`), wtnsFastFile.data);
    }
    const { proof, publicSignals } = await snarkjs_1.default.groth16.prove(beaconZkeyFastFile, wtnsFastFile);
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.proof.json`), JSON.stringify(proof));
        await fs.writeFile(path.join(debug.path, `${circuit.name}.public.json`), JSON.stringify(publicSignals));
    }
    const verified = await snarkjs_1.default.groth16.verify(verificationKey, publicSignals, proof);
    if (!verified) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Could not verify the proof for circuit named: ${circuit.name}`);
    }
    await fs.mkdir(path.dirname(circuit.wasm), { recursive: true });
    await fs.writeFile(circuit.wasm, wasmFastFile.data);
    await fs.mkdir(path.dirname(circuit.zkey), { recursive: true });
    await fs.writeFile(circuit.zkey, beaconZkeyFastFile.data);
    await fs.mkdir(path.dirname(circuit.r1cs), { recursive: true });
    await fs.writeFile(circuit.r1cs, r1csFastFile.data);
    await fs.mkdir(path.dirname(circuit.vkey), { recursive: true });
    await fs.writeFile(circuit.vkey, JSON.stringify(verificationKey));
    return { type: "mem", name: circuit.name, data: beaconZkeyFastFile.data };
}
async function plonk({ circuit, debug, wasm: wasmFastFile, r1cs: r1csFastFile, ptau, }) {
    const input = await getInputJson(circuit.input);
    const newKeyFastFile = { type: "mem" };
    await snarkjs_1.default.plonk.setup(r1csFastFile, ptau, newKeyFastFile);
    if (!newKeyFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate new zkey for circuit named: ${circuit.name}`);
    }
    const verificationKey = await snarkjs_1.default.zKey.exportVerificationKey(newKeyFastFile);
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.vkey.json`), JSON.stringify(verificationKey));
    }
    const wtnsFastFile = { type: "mem" };
    await snarkjs_1.default.wtns.calculate(input, wasmFastFile, wtnsFastFile);
    if (!wtnsFastFile.data) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to generate witness for circuit named: ${circuit.name}`);
    }
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.wtns`), wtnsFastFile.data);
    }
    const { proof, publicSignals } = await snarkjs_1.default.plonk.prove(newKeyFastFile, wtnsFastFile);
    if (debug) {
        await fs.writeFile(path.join(debug.path, `${circuit.name}.proof.json`), JSON.stringify(proof));
        await fs.writeFile(path.join(debug.path, `${circuit.name}.public.json`), JSON.stringify(publicSignals));
    }
    const verified = await snarkjs_1.default.plonk.verify(verificationKey, publicSignals, proof);
    if (!verified) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Could not verify the proof for circuit named: ${circuit.name}`);
    }
    await fs.mkdir(path.dirname(circuit.wasm), { recursive: true });
    await fs.writeFile(circuit.wasm, wasmFastFile.data);
    await fs.mkdir(path.dirname(circuit.zkey), { recursive: true });
    await fs.writeFile(circuit.zkey, newKeyFastFile.data);
    await fs.mkdir(path.dirname(circuit.r1cs), { recursive: true });
    await fs.writeFile(circuit.r1cs, r1csFastFile.data);
    await fs.mkdir(path.dirname(circuit.vkey), { recursive: true });
    await fs.writeFile(circuit.vkey, JSON.stringify(verificationKey));
    return { type: "mem", name: circuit.name, data: newKeyFastFile.data };
}
config_1.task(exports.TASK_CIRCOM, "compile circom circuits and template Verifier")
    .addFlag("deterministic", "enable deterministic builds for groth16 protocol circuits (except for .wasm)")
    .addFlag("debug", "output intermediate files to artifacts directory, generally for debug")
    .addOptionalParam("circuit", "limit your circom task to a single circuit name", undefined, config_1.types.string)
    .setAction(circomCompile);
async function circomCompile({ deterministic, debug, circuit: onlyCircuitNamed }, hre) {
    const artifactPath = path.join(hre.config.paths.artifacts, "circom");
    const { ptauDownload } = hre.config.circom;
    if (debug || ptauDownload) {
        await fs.mkdir(path.join(artifactPath), { recursive: true });
    }
    if (ptauDownload) {
        if (fs_1.existsSync(hre.config.circom.ptau)) {
            logger_1.default.info(`Using cached Powers of Tau file at ${hre.config.circom.ptau}`);
        }
        else {
            logger_1.default.info(`Downloading Powers of Tau file from ${ptauDownload}`);
            await undici_1.stream(ptauDownload, { method: "GET", opaque: { path: hre.config.circom.ptau } }, ({ opaque }) => fs_1.createWriteStream(opaque.path));
        }
    }
    if (!fs_1.existsSync(hre.config.circom.ptau)) {
        throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Could not locate ptau file: ${hre.config.circom.ptau}`);
    }
    const zkeys = [];
    for (const circuit of hre.config.circom.circuits) {
        if (onlyCircuitNamed && onlyCircuitNamed !== circuit.name) {
            continue;
        }
        const compiler = circuit.version === 1 ? circom1 : circom2;
        let compilerOutput;
        try {
            compilerOutput = await compiler({
                circuit,
                debug: debug ? { path: artifactPath } : undefined,
            });
        }
        catch (err) {
            throw new plugins_1.HardhatPluginError(exports.PLUGIN_NAME, `Unable to compile circuit named: ${circuit.name}`, err);
        }
        const { r1cs, wasm } = compilerOutput;
        const _cir = await snarkjs_1.default.r1cs.info(r1cs);
        const snarker = circuit.protocol === "groth16" ? groth16 : plonk;
        const zkey = await snarker({
            circuit,
            debug: debug ? { path: artifactPath } : undefined,
            wasm,
            r1cs,
            ptau: hre.config.circom.ptau,
            // Only used by groth16
            deterministic,
        });
        zkeys.push(zkey);
    }
    await hre.run(exports.TASK_CIRCOM_TEMPLATE, { zkeys: zkeys });
}
function normalize(basePath, userPath) {
    let normalPath;
    if (userPath === undefined) {
        return undefined;
    }
    else {
        if (path.isAbsolute(userPath)) {
            normalPath = path.normalize(userPath);
        }
        else {
            if (basePath === undefined) {
                return undefined;
            }
            // We resolve relative paths starting from the project's root.
            // Please keep this convention to avoid confusion.
            normalPath = path.normalize(path.join(basePath, userPath));
        }
    }
    return normalPath;
}
config_1.subtask(exports.TASK_CIRCOM_TEMPLATE, "template Verifier with zkeys")
    .addParam("zkeys", "array of zkey fastfiles (can be passed directly to SnarkJS)", undefined, config_1.types.any)
    .setAction(circomTemplate);
async function circomTemplate({ zkeys }, hre) {
    const warning = "// THIS FILE IS GENERATED BY HARDHAT-CIRCOM. DO NOT EDIT THIS FILE.\n";
    const snarkjsRoot = path.dirname(require.resolve("snarkjs"));
    const templateDir = fs_1.existsSync(path.join(snarkjsRoot, "templates")) ? "templates" : "../templates";
    const verifierGroth16TemplatePath = path.join(snarkjsRoot, templateDir, "verifier_groth16.sol.ejs");
    const verifierPlonkTemplatePath = path.join(snarkjsRoot, templateDir, "verifier_plonk.sol.ejs");
    const groth16Template = await fs.readFile(verifierGroth16TemplatePath, "utf8");
    const plonkTemplate = await fs.readFile(verifierPlonkTemplatePath, "utf8");
    for (const zkey of zkeys) {
        const circuitSol = await snarkjs_1.default.zKey.exportSolidityVerifier(zkey, {
            groth16: groth16Template,
            plonk: plonkTemplate,
        });
        const finalSol = warning + circuitSol;
        const name = camelcase_1.default(zkey.name, {
            pascalCase: true,
            preserveConsecutiveUppercase: true,
            locale: false,
        });
        const verifier = path.join(hre.config.paths.sources, `${name}Verifier.sol`);
        await fs.mkdir(path.dirname(verifier), { recursive: true });
        await fs.writeFile(verifier, finalSol);
    }
}
// Testing utility
// Based on https://github.com/iden3/circom_tester/blob/3e9963ce7d371c15978674331cff1d14027d209d/wasm/tester.js
// but adapted for use in the hardhat-circom infrastructure
class CircuitTestUtils {
    constructor({ r1cs, wasm, sym, }) {
        Object.defineProperty(this, "r1cs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "wasm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sym", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "symbols", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "F", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "constraints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.r1cs = r1cs;
        this.wasm = wasm;
        this.sym = sym;
    }
    async calculateWitness(input, sanityCheck) {
        const wc = await circom_runtime_1.WitnessCalculatorBuilder(this.wasm.data);
        return wc.calculateWitness(input, sanityCheck);
    }
    async calculateLabeledWitness(input, sanityCheck) {
        const wc = await circom_runtime_1.WitnessCalculatorBuilder(this.wasm.data);
        const witness = await wc.calculateWitness(input, sanityCheck);
        const symbols = await this.loadSymbols();
        const labels = {};
        for (const n in symbols) {
            let v = undefined;
            if (typeof witness[symbols[n].varIdx] !== "undefined") {
                v = witness[symbols[n].varIdx].toString();
            }
            labels[n] = v;
        }
        return new LabeledWitness(witness, labels);
    }
    async loadSymbols() {
        if (!this.symbols) {
            this.symbols = {};
            const lines = this.sym.data.toString().split("\n");
            for (const line of lines) {
                const arr = line.split(",");
                if (arr.length != 4)
                    continue;
                this.symbols[arr[3]] = {
                    labelIdx: Number(arr[0]),
                    varIdx: Number(arr[1]),
                    componentIdx: Number(arr[2]),
                };
            }
        }
        return this.symbols;
    }
    async loadConstraints() {
        if (!this.constraints) {
            const r1cs = await r1csfile_1.readR1cs(this.r1cs, {
                loadConstraints: true,
                loadMaps: false,
                getFieldFromPrime: (p) => new ffjavascript_1.F1Field(p),
            });
            this.F = r1cs.F;
            this.constraints = r1cs.constraints;
        }
        return this.constraints;
    }
    async assertOut(actualOut, expectedOut) {
        const symbols = await this.loadSymbols();
        const checkObject = (prefix, eOut) => {
            if (Array.isArray(eOut)) {
                for (let i = 0; i < eOut.length; i++) {
                    checkObject(`${prefix}[${i}]`, eOut[i]);
                }
            }
            else if (isPlainObject(eOut)) {
                for (const k in eOut) {
                    checkObject(`${prefix}.${k}`, eOut[k]);
                }
            }
            else {
                if (typeof symbols[prefix] == "undefined") {
                    assert_1.default(false, `Output variable not defined: ${prefix}`);
                }
                const ba = actualOut[symbols[prefix].varIdx].toString();
                const be = eOut.toString();
                assert_1.default.strictEqual(ba, be, prefix);
            }
        };
        checkObject("main", expectedOut);
    }
    async getDecoratedOutput(witness) {
        const symbols = await this.loadSymbols();
        const lines = [];
        for (const n in symbols) {
            let v;
            if (typeof witness[symbols[n].varIdx] !== "undefined") {
                v = witness[symbols[n].varIdx].toString();
            }
            else {
                v = "undefined";
            }
            lines.push(`${n} --> ${v}`);
        }
        return lines.join("\n");
    }
    async checkConstraints(witness) {
        const constraints = await this.loadConstraints();
        const evalLC = (lc) => {
            const F = this.F;
            let v = F.zero;
            for (const w in lc) {
                v = F.add(v, F.mul(lc[w], F.e(witness[w])));
            }
            return v;
        };
        const checkConstraint = (constraint) => {
            const F = this.F;
            const a = evalLC(constraint[0]);
            const b = evalLC(constraint[1]);
            const c = evalLC(constraint[2]);
            assert_1.default(F.isZero(F.sub(F.mul(a, b), c)), "Constraint doesn't match");
        };
        for (let i = 0; i < constraints.length; i++) {
            checkConstraint(constraints[i]);
        }
    }
}
exports.CircuitTestUtils = CircuitTestUtils;
class LabeledWitness {
    constructor(witness, labels) {
        Object.defineProperty(this, "length", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, Symbol.toStringTag, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "LabeledWitness"
        });
        this.length = witness.length;
        for (const [idx, val] of witness.entries()) {
            this[idx] = val;
        }
        this._labels = labels;
        for (const [label, val] of Object.entries(labels)) {
            this[label] = val;
        }
    }
    [util_1.inspect.custom]() {
        return this._labels;
    }
}
exports.LabeledWitness = LabeledWitness;
// Some helpers
function isPlainObject(val) {
    if (typeof val === "object") {
        if (val != null) {
            if (val.constructor.name === "Object") {
                for (const v of Object.values(val)) {
                    if (typeof v.toString !== "function") {
                        return false;
                    }
                }
                return true;
            }
        }
    }
    return false;
}
